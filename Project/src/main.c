/*
 *  ECE355 Project
 *  Benjamin B Jackson		V00919896
 *  Jacob Arychuk		V00975301
 *
 *  This project is an embedded system for monitoring two signals. An outside
 *  signal generated input on pin PA2 a pulsewidth-modulated (PWM) signal
 *  generated by a 555 timer (NE555 IC). An Optocoupler (4N35 IC), driven by the
 *  microcontroller on the STMF0 Discovery board, will be used to control the
 *  PWM signal frequency and duty cycle.
 */


#include <stdio.h>
#include <stdlib.h>
#include "diag/trace.h"
#include "cmsis/cmsis_device.h"

// Sample pragmas to cope with warnings. Please note the related line at the end of this function, used to pop the compiler diagnostics status.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#pragma GCC diagnostic ignored "-Wreturn-type"

// Definitions
#define myTIM2_PRESCALER ((uint16_t)0x0000) 		// Clock prescaler for TIM2 timer (no prescaling)
#define myTIM2_PERIOD ((uint32_t)0xFFFFFFFF) 		// Maximum possible setting for overflow
#define myTIM3_PRESCALER ((uint16_t)0x0000) 		// Clock prescaler for TIM3 timer (no prescaling)
#define myTIM3_PERIOD ((uint32_t)0xFFFFFFFF) 		// Maximum possible setting for overflow
#define sysClock 48000000				// System clock speed

SPI_HandleTypeDef SPI_Handle;

void GPIOA_Init(void);
void myGPIOB_Init(void);
void TIM2_Init(void);
void myTIM3_Init(void);
void EXTI_Init(void);
void ADC_Init(void);
void DAC_Init(void);
void oled_config(void);
void refresh_OLED(void);
void oled_Write(unsigned char);
void oled_Write_Cmd(unsigned char);
void oled_Write_Data(unsigned char);
void delay(uint32_t time);

// Initialization commands for LED display
unsigned char oled_init_cmds[] = {
    0xAE,
    0x20, 0x00,
    0x40,
    0xA0 | 0x01,
    0xA8, 0x40 - 1,
    0xC0 | 0x08,
    0xD3, 0x00,
    0xDA, 0x32,
    0xD5, 0x80,
    0xD9, 0x22,
    0xDB, 0x30,
    0x81, 0xFF,
    0xA4,
    0xA6,
    0xAD, 0x30,
    0x8D, 0x10,
    0xAE | 0x01,
    0xC0,
    0xA0
};

// Character specifications for LED display (1 row = 8 bytes = 1 ASCII character)
unsigned char Characters[][8] = {
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // SPACE
    {0b00000000, 0b00000000, 0b01011111, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // !
    {0b00000000, 0b00000111, 0b00000000, 0b00000111, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // "
    {0b00010100, 0b01111111, 0b00010100, 0b01111111, 0b00010100,0b00000000, 0b00000000, 0b00000000},  // #
    {0b00100100, 0b00101010, 0b01111111, 0b00101010, 0b00010010,0b00000000, 0b00000000, 0b00000000},  // $
    {0b00100011, 0b00010011, 0b00001000, 0b01100100, 0b01100010,0b00000000, 0b00000000, 0b00000000},  // %
    {0b00110110, 0b01001001, 0b01010101, 0b00100010, 0b01010000,0b00000000, 0b00000000, 0b00000000},  // &
    {0b00000000, 0b00000101, 0b00000011, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // '
    {0b00000000, 0b00011100, 0b00100010, 0b01000001, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // (
    {0b00000000, 0b01000001, 0b00100010, 0b00011100, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // )
    {0b00010100, 0b00001000, 0b00111110, 0b00001000, 0b00010100,0b00000000, 0b00000000, 0b00000000},  // *
    {0b00001000, 0b00001000, 0b00111110, 0b00001000, 0b00001000,0b00000000, 0b00000000, 0b00000000},  // +
    {0b00000000, 0b01010000, 0b00110000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // ,
    {0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000,0b00000000, 0b00000000, 0b00000000},  // -
    {0b00000000, 0b01100000, 0b01100000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // .
    {0b00100000, 0b00010000, 0b00001000, 0b00000100, 0b00000010,0b00000000, 0b00000000, 0b00000000},  // /
    {0b00111110, 0b01010001, 0b01001001, 0b01000101, 0b00111110,0b00000000, 0b00000000, 0b00000000},  // 0
    {0b00000000, 0b01000010, 0b01111111, 0b01000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // 1
    {0b01000010, 0b01100001, 0b01010001, 0b01001001, 0b01000110,0b00000000, 0b00000000, 0b00000000},  // 2
    {0b00100001, 0b01000001, 0b01000101, 0b01001011, 0b00110001,0b00000000, 0b00000000, 0b00000000},  // 3
    {0b00011000, 0b00010100, 0b00010010, 0b01111111, 0b00010000,0b00000000, 0b00000000, 0b00000000},  // 4
    {0b00100111, 0b01000101, 0b01000101, 0b01000101, 0b00111001,0b00000000, 0b00000000, 0b00000000},  // 5
    {0b00111100, 0b01001010, 0b01001001, 0b01001001, 0b00110000,0b00000000, 0b00000000, 0b00000000},  // 6
    {0b00000011, 0b00000001, 0b01110001, 0b00001001, 0b00000111,0b00000000, 0b00000000, 0b00000000},  // 7
    {0b00110110, 0b01001001, 0b01001001, 0b01001001, 0b00110110,0b00000000, 0b00000000, 0b00000000},  // 8
    {0b00000110, 0b01001001, 0b01001001, 0b00101001, 0b00011110,0b00000000, 0b00000000, 0b00000000},  // 9
    {0b00000000, 0b00110110, 0b00110110, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // :
    {0b00000000, 0b01010110, 0b00110110, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // ;
    {0b00001000, 0b00010100, 0b00100010, 0b01000001, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // <
    {0b00010100, 0b00010100, 0b00010100, 0b00010100, 0b00010100,0b00000000, 0b00000000, 0b00000000},  // =
    {0b00000000, 0b01000001, 0b00100010, 0b00010100, 0b00001000,0b00000000, 0b00000000, 0b00000000},  // >
    {0b00000010, 0b00000001, 0b01010001, 0b00001001, 0b00000110,0b00000000, 0b00000000, 0b00000000},  // ?
    {0b00110010, 0b01001001, 0b01111001, 0b01000001, 0b00111110,0b00000000, 0b00000000, 0b00000000},  // @
    {0b01111110, 0b00010001, 0b00010001, 0b00010001, 0b01111110,0b00000000, 0b00000000, 0b00000000},  // A
    {0b01111111, 0b01001001, 0b01001001, 0b01001001, 0b00110110,0b00000000, 0b00000000, 0b00000000},  // B
    {0b00111110, 0b01000001, 0b01000001, 0b01000001, 0b00100010,0b00000000, 0b00000000, 0b00000000},  // C
    {0b01111111, 0b01000001, 0b01000001, 0b00100010, 0b00011100,0b00000000, 0b00000000, 0b00000000},  // D
    {0b01111111, 0b01001001, 0b01001001, 0b01001001, 0b01000001,0b00000000, 0b00000000, 0b00000000},  // E
    {0b01111111, 0b00001001, 0b00001001, 0b00001001, 0b00000001,0b00000000, 0b00000000, 0b00000000},  // F
    {0b00111110, 0b01000001, 0b01001001, 0b01001001, 0b01111010,0b00000000, 0b00000000, 0b00000000},  // G
    {0b01111111, 0b00001000, 0b00001000, 0b00001000, 0b01111111,0b00000000, 0b00000000, 0b00000000},  // H
    {0b01000000, 0b01000001, 0b01111111, 0b01000001, 0b01000000,0b00000000, 0b00000000, 0b00000000},  // I
    {0b00100000, 0b01000000, 0b01000001, 0b00111111, 0b00000001,0b00000000, 0b00000000, 0b00000000},  // J
    {0b01111111, 0b00001000, 0b00010100, 0b00100010, 0b01000001,0b00000000, 0b00000000, 0b00000000},  // K
    {0b01111111, 0b01000000, 0b01000000, 0b01000000, 0b01000000,0b00000000, 0b00000000, 0b00000000},  // L
    {0b01111111, 0b00000010, 0b00001100, 0b00000010, 0b01111111,0b00000000, 0b00000000, 0b00000000},  // M
    {0b01111111, 0b00000100, 0b00001000, 0b00010000, 0b01111111,0b00000000, 0b00000000, 0b00000000},  // N
    {0b00111110, 0b01000001, 0b01000001, 0b01000001, 0b00111110,0b00000000, 0b00000000, 0b00000000},  // O
    {0b01111111, 0b00001001, 0b00001001, 0b00001001, 0b00000110,0b00000000, 0b00000000, 0b00000000},  // P
    {0b00111110, 0b01000001, 0b01010001, 0b00100001, 0b01011110,0b00000000, 0b00000000, 0b00000000},  // Q
    {0b01111111, 0b00001001, 0b00011001, 0b00101001, 0b01000110,0b00000000, 0b00000000, 0b00000000},  // R
    {0b01000110, 0b01001001, 0b01001001, 0b01001001, 0b00110001,0b00000000, 0b00000000, 0b00000000},  // S
    {0b00000001, 0b00000001, 0b01111111, 0b00000001, 0b00000001,0b00000000, 0b00000000, 0b00000000},  // T
    {0b00111111, 0b01000000, 0b01000000, 0b01000000, 0b00111111,0b00000000, 0b00000000, 0b00000000},  // U
    {0b00011111, 0b00100000, 0b01000000, 0b00100000, 0b00011111,0b00000000, 0b00000000, 0b00000000},  // V
    {0b00111111, 0b01000000, 0b00111000, 0b01000000, 0b00111111,0b00000000, 0b00000000, 0b00000000},  // W
    {0b01100011, 0b00010100, 0b00001000, 0b00010100, 0b01100011,0b00000000, 0b00000000, 0b00000000},  // X
    {0b00000111, 0b00001000, 0b01110000, 0b00001000, 0b00000111,0b00000000, 0b00000000, 0b00000000},  // Y
    {0b01100001, 0b01010001, 0b01001001, 0b01000101, 0b01000011,0b00000000, 0b00000000, 0b00000000},  // Z
    {0b01111111, 0b01000001, 0b00000000, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // [
    {0b00010101, 0b00010110, 0b01111100, 0b00010110, 0b00010101,0b00000000, 0b00000000, 0b00000000},  // back slash
    {0b00000000, 0b00000000, 0b00000000, 0b01000001, 0b01111111,0b00000000, 0b00000000, 0b00000000},  // ]
    {0b00000100, 0b00000010, 0b00000001, 0b00000010, 0b00000100,0b00000000, 0b00000000, 0b00000000},  // ^
    {0b01000000, 0b01000000, 0b01000000, 0b01000000, 0b01000000,0b00000000, 0b00000000, 0b00000000},  // _
    {0b00000000, 0b00000001, 0b00000010, 0b00000100, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // `
    {0b00100000, 0b01010100, 0b01010100, 0b01010100, 0b01111000,0b00000000, 0b00000000, 0b00000000},  // a
    {0b01111111, 0b01001000, 0b01000100, 0b01000100, 0b00111000,0b00000000, 0b00000000, 0b00000000},  // b
    {0b00111000, 0b01000100, 0b01000100, 0b01000100, 0b00100000,0b00000000, 0b00000000, 0b00000000},  // c
    {0b00111000, 0b01000100, 0b01000100, 0b01001000, 0b01111111,0b00000000, 0b00000000, 0b00000000},  // d
    {0b00111000, 0b01010100, 0b01010100, 0b01010100, 0b00011000,0b00000000, 0b00000000, 0b00000000},  // e
    {0b00001000, 0b01111110, 0b00001001, 0b00000001, 0b00000010,0b00000000, 0b00000000, 0b00000000},  // f
    {0b00001100, 0b01010010, 0b01010010, 0b01010010, 0b00111110,0b00000000, 0b00000000, 0b00000000},  // g
    {0b01111111, 0b00001000, 0b00000100, 0b00000100, 0b01111000,0b00000000, 0b00000000, 0b00000000},  // h
    {0b00000000, 0b01000100, 0b01111101, 0b01000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // i
    {0b00100000, 0b01000000, 0b01000100, 0b00111101, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // j
    {0b01111111, 0b00010000, 0b00101000, 0b01000100, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // k
    {0b00000000, 0b01000001, 0b01111111, 0b01000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // l
    {0b01111100, 0b00000100, 0b00011000, 0b00000100, 0b01111000,0b00000000, 0b00000000, 0b00000000},  // m
    {0b01111100, 0b00001000, 0b00000100, 0b00000100, 0b01111000,0b00000000, 0b00000000, 0b00000000},  // n
    {0b00111000, 0b01000100, 0b01000100, 0b01000100, 0b00111000,0b00000000, 0b00000000, 0b00000000},  // o
    {0b01111100, 0b00010100, 0b00010100, 0b00010100, 0b00001000,0b00000000, 0b00000000, 0b00000000},  // p
    {0b00001000, 0b00010100, 0b00010100, 0b00011000, 0b01111100,0b00000000, 0b00000000, 0b00000000},  // q
    {0b01111100, 0b00001000, 0b00000100, 0b00000100, 0b00001000,0b00000000, 0b00000000, 0b00000000},  // r
    {0b01001000, 0b01010100, 0b01010100, 0b01010100, 0b00100000,0b00000000, 0b00000000, 0b00000000},  // s
    {0b00000100, 0b00111111, 0b01000100, 0b01000000, 0b00100000,0b00000000, 0b00000000, 0b00000000},  // t
    {0b00111100, 0b01000000, 0b01000000, 0b00100000, 0b01111100,0b00000000, 0b00000000, 0b00000000},  // u
    {0b00011100, 0b00100000, 0b01000000, 0b00100000, 0b00011100,0b00000000, 0b00000000, 0b00000000},  // v
    {0b00111100, 0b01000000, 0b00111000, 0b01000000, 0b00111100,0b00000000, 0b00000000, 0b00000000},  // w
    {0b01000100, 0b00101000, 0b00010000, 0b00101000, 0b01000100,0b00000000, 0b00000000, 0b00000000},  // x
    {0b00001100, 0b01010000, 0b01010000, 0b01010000, 0b00111100,0b00000000, 0b00000000, 0b00000000},  // y
    {0b01000100, 0b01100100, 0b01010100, 0b01001100, 0b01000100,0b00000000, 0b00000000, 0b00000000},  // z
    {0b00000000, 0b00001000, 0b00110110, 0b01000001, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // {
    {0b00000000, 0b00000000, 0b01111111, 0b00000000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // |
    {0b00000000, 0b01000001, 0b00110110, 0b00001000, 0b00000000,0b00000000, 0b00000000, 0b00000000},  // }
    {0b00001000, 0b00001000, 0b00101010, 0b00011100, 0b00001000,0b00000000, 0b00000000, 0b00000000},  // ~
    {0b00001000, 0b00011100, 0b00101010, 0b00001000, 0b00001000,0b00000000, 0b00000000, 0b00000000}   // <-
};

// Call this function to boost the STM32F0xx clock to 48 MHz
void SystemClock48MHz(void) {

    // Disable the PLL
    RCC->CR &= ~(RCC_CR_PLLON);

    // Wait for the PLL to unlock
    while (( RCC->CR & RCC_CR_PLLRDY ) != 0 );

    // Configure the PLL for 48-MHz system clock
    RCC->CFGR = 0x00280000;

    // Enable the PLL
    RCC->CR |= RCC_CR_PLLON;

    // Wait for the PLL to lock
    while (( RCC->CR & RCC_CR_PLLRDY ) != RCC_CR_PLLRDY );

    // Switch the processor to the PLL clock source
    RCC->CFGR = ( RCC->CFGR & (~RCC_CFGR_SW_Msk)) | RCC_CFGR_SW_PLL;

    // Update the system with the new clock frequency
    SystemCoreClockUpdate();

}

// Global Variables
unsigned int freq = 0;				// Frequency from either function generator or NE555 timer
unsigned int res = 0;				// Resistance from potentiometer
unsigned int inSig = 1; 			// Using input EXTI1(NE555 timer)/EXTI2(function generator) = 0/1
unsigned int first_edgeTimer = 0; 		// Handle first/second = 0/1 edge of NE555 timer signal
unsigned int first_edgeSigGen = 0; 		// Handle first/second = 0/1 edge of function generator signal

int main(int argc, char* argv[]) {

	SystemClock48MHz();
	trace_printf("System clock: %u Hz\n", SystemCoreClock);

	GPIOA_Init();
	myGPIOB_Init();
	TIM2_Init();
	myTIM3_Init();
	EXTI_Init();
	ADC_Init();
	DAC_Init();
	oled_config();

	// Infinite loop
	while(1) {

		// Start conversion process
		ADC1->CR |= 0x4;

		// Wait until end of conversion flag is set
		while((ADC1->ISR & 0x2) == 0);

		// Read the low 12 bits from data register
		unsigned int adc_value = (ADC1->DR & 0xFFF);

		res = (int)((adc_value * 5000 ) / 4095); // Max resistance is 5k Ohms
		//trace_printf("Value going to ADC from POT: %u\tres = %u\n", adc_value, res);

		// Send value from ADC to DAC
		DAC1->DHR12R1 = ADC1->DR & 0xFFF;

		refresh_OLED();

	}

	return 0;

}

double period_calc(unsigned int count) {
	// Calculate and return signal period by changing from CPU frequency (48MHz) to microseconds
	return count/48.0;
}

double frequency_calc(unsigned int count, double sig_period) {
	// Calculate and return signal frequency (+0.5 for rounding)
	return (1000000.0/sig_period) + 0.5;
}

void GPIOA_Init() {

	// Enable clock for GPIOA
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;

	// Configure PA0-2 as input mode
	GPIOA->MODER &= ~(GPIO_MODER_MODER0);
	GPIOA->MODER &= ~(GPIO_MODER_MODER1);
	GPIOA->MODER &= ~(GPIO_MODER_MODER2);

	// Set no pull-up/pull-down for PA0-2
	GPIOA->PUPDR &= ~(GPIO_PUPDR_PUPDR0);
	GPIOA->PUPDR &= ~(GPIO_PUPDR_PUPDR1);
	GPIOA->PUPDR &= ~(GPIO_PUPDR_PUPDR2);

}

void myGPIOB_Init(void) {

		//Enable Clock
		RCC->AHBENR |= RCC_AHBENR_GPIOBEN;

		// Configure PB3 and PB5 as AF (see "I/O Examples" Slide 47)
		GPIOB->MODER |= (GPIO_MODER_MODER3_1 | GPIO_MODER_MODER5_1);

		// Set to AF0 AFR[0] = AFRL (see reference manual)
		GPIOB->AFR[0] &= ~(GPIO_AFRL_AFSEL3 | GPIO_AFRL_AFSEL5);

		// Ensure no pull-up/pull down for PB3 and PB5 (see "I/O Examples" Slide 47)
		GPIOB->PUPDR &= ~(GPIO_PUPDR_PUPDR3 | GPIO_PUPDR_PUPDR5);

		// Configure PB4, PB6, PB7 as output (see "I/O Examples" Slide 47 and reference manual Page 159)
		GPIOB->MODER |= (GPIO_MODER_MODER4_0 | GPIO_MODER_MODER6_0 | GPIO_MODER_MODER7_0);

		// Ensure no pull-up/pull-down for PB4, PB6, PB7 (see "I/O Examples" Slide 47)
		GPIOB->PUPDR &= ~(GPIO_PUPDR_PUPDR4 | GPIO_PUPDR_PUPDR6 | GPIO_PUPDR_PUPDR7);

}

void ADC_Init() {

	// Enable clock for ADC
	RCC->APB2ENR |= 0x200;

	// Configure PA5 as analog mode
	GPIOA->MODER |= 0xC00;

	// Configure ADC
	ADC1->CFGR1 &= 0xFFFFFFE7; 	// Set 12-bit resolution
	ADC1->CFGR1 &= 0xFFFFFFDF; 	// Set right-aligned data
	ADC1->CFGR1 |= 0x1000; 		// Set to overwrite contents when an overrun is detected
	ADC1->CFGR1 |= 0x2000; 		// Enable continuous conversion mode

	// Select Channel 5 for conversion
	ADC1->CHSELR |= 0x20;

	// Set maximum sampling time
	ADC1->SMPR |= 0x7;

	// Enable ADC process
	ADC1->CR |= 0x1;

	// Wait until ADC ready flag is set
	while(((ADC1->ISR & 0x1) == 0));

}

void DAC_Init() {

	// Enable clock for DAC
	RCC->APB1ENR |= 0x20000000;

	// Configure PA4 as analog mode
	GPIOA->MODER |= 0x300;

	// Enable output channel
	DAC1->CR |= 0x1;

	// Enable output buffer and disable trigger
	DAC1->CR &= 0xFFFFFFF9;

}

void TIM2_Init(void) {

	// Enable clock for TIM2
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

	// Set configuration: buffer the TIM2_ARR register, count up, stop on overflow, generate interrupt on overflow
	TIM2->CR1 = ((uint16_t)0x008C);

	// Set clock prescaler value
	TIM2->PSC = TIM2_PRESCALER;

	// Set auto-reloading delay
	TIM2->ARR = TIM2_PERIOD;

	// Update timer registers
	TIM2->EGR = ((uint16_t)0x0001);

	// Assign TIM2 interrupt priority in NVIC
	NVIC_SetPriority(TIM2_IRQn, 0);

	// Enable TIM2 interrupts in NVIC
	NVIC_EnableIRQ(TIM2_IRQn);

	// Enable TIM2 interrupts
	TIM2->DIER |= TIM_DIER_UIE;

}

void TIM2_IRQHandler(void) {

	// Check if update interrupt flag is not set
	if ((TIM2->SR & TIM_SR_UIF) == 0) return;

	// Clear update interrupt flag
	TIM2->SR &= ~(TIM_SR_UIF);

	// Restart stopped timer
	TIM2->CR1 |= TIM_CR1_CEN;

}

void myTIM3_Init(void) {

	// Enable clock
	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;

	// Configure: count up, buffer auto-reload, enable update events
	TIM3->CR1 = ((uint16_t)0x0080);	//0x008C  buffer auto-reload, count up, stop on overflow, enable update events, interrupt on overflow only

	// Set clock prescaler value for milliseconds
	TIM3->PSC = 48000 - 1; // 48 MHz / 48000 = 1000 Hz (1 ms tick)

	// Set auto-reloaded delay
	TIM3->ARR = 0xFFFF;

	// Update timer registers
	TIM3->EGR = ((uint16_t)0x0001);

}

void TIM3_IRQHandler(void) {

	// Check if update interrupt flag is set
	if ((TIM3->SR & TIM_SR_UIF) != 0) {

		trace_printf("\nOverflow!\n");

		// Clear update interrupt flag
		TIM3->SR &= ~(TIM_SR_UIF);

		// Restart stopped timer
		TIM3->CR1 |= TIM_CR1_CEN;

	}

}


void EXTI_Init() {

	// Map EXTI0-2 to PA0-2
	SYSCFG->EXTICR[0] &= ((uint16_t)0xF000);

	// Set rising-edge trigger for EXTI0-2
	EXTI->RTSR |= ((uint32_t)0x00000007);

	// Unmask interrupts from EXTI0 line
	EXTI->IMR |= ((uint32_t)0x00000001);

	// Mask interrupts from EXTI1 line (not starting with NE555 timer)
	EXTI->IMR &= 0xFFFFFFFD;

	// Unmask interrupts from EXTI2 line (starting with function generator)
	EXTI->IMR |= 0x4;

	// Set EXTI0-3 interrupt priority in NVIC
	NVIC_SetPriority(EXTI0_1_IRQn, 0);
	NVIC_SetPriority(EXTI2_3_IRQn, 0);

	// Enable EXTI interrupts in NVIC
	NVIC_EnableIRQ(EXTI0_1_IRQn);
	NVIC_EnableIRQ(EXTI2_3_IRQn);

}

// This handler is declared in system/src/cmsis/vectors_stm32f051x8.c
void EXTI0_1_IRQHandler() {

    volatile unsigned int count = 0;
    volatile double sig_period = 0;
    volatile double sig_frequency = 0;

    // Check if EXTI0 interrupt pending flag is set (for the button)
    if ((EXTI->PR & EXTI_PR_PR0) != 0) {

		// Switch input: EXTI1(NE555 timer)/EXTI2(function generator) = 0/1
		inSig ^= 0x1;

		// Using EXTI1 (NE555 timer)
		if(inSig == 0){
			// Unmask interrupts from EXTI1 line
			EXTI->IMR |= 0x2; // Set bit MR1 to 1 to unmask (see reference manual Page 199)
			// Mask interrupts from EXTI2 line
			EXTI->IMR &= 0xFFFFFFFFB; // Clear bit MR2 to 0 to mask (see reference manual Page 199)
		}

		// Using EXTI2 (function generator)
		else {
			// Mask interrupts from EXTI1 line
			EXTI->IMR &= 0xFFFFFFFD; // Clear bit MR1 to 0 to mask (see reference manual Page 199)
			// Unmask interrupts from EXTI2 line
			EXTI->IMR |= 0x4; // Set bit MR2 to 1 to unmask (see reference manual Page 199)
		}

	// Clear EXTI0 interrupt pending flag
	EXTI->PR |= ((uint32_t)0x00000001); // A pending register (PR) bit is cleared by writing 1 to it

    }

    // Check if EXTI1 interrupt pending flag is set (for the NE555 timer)
    if ((EXTI->PR & EXTI_PR_PR1) != 0) {
	//EXTI->PR |= ((uint32_t)0x00000002); // A pending register (PR) bit is cleared by writing 1 to it

	// Handle first edge
	if(first_edgeTimer == 0) {
		// Clear count register
		TIM2->CNT = ((uint32_t)0x00000000);
		// Start timer
		TIM2->CR1 |= ((uint16_t)0x0001);
		// Update flag
		first_edgeTimer = 1;
	}

	// Handle second edge
	else {
		// Stop timer
		TIM2->CR1 &= ((uint16_t)0xFFFE);
		// Read out count register
		count = TIM2->CNT;
		// Calculate signal period by changing from CPU frequency (48MHz) to microseconds
		sig_period = (int)period_calc(count);
		// Calculate signal frequency (+ 0.5 for rounding)
		sig_frequency = frequency_calc(count, sig_period);
		freq = (unsigned int) sig_frequency;
		// Reset flag
		first_edgeTimer = 0;
	}

	// Clear EXTI1 interrupt pending flag
	EXTI->PR |= ((uint32_t)0x00000002); // A pending register (PR) bit is cleared by writing 1 to it

    }

}

// This handler is declared in system/src/cmsis/vectors_stm32f051x8.c
void EXTI2_3_IRQHandler() {

    volatile unsigned int count = 0;
    volatile double sig_period = 0;
    volatile double sig_frequency = 0;

    // Check if EXTI2 interrupt pending flag is set (for the function generator)
	if ((EXTI->PR & EXTI_PR_PR2) != 0) {

		// Handle first edge
		if(first_edgeSigGen == 0) {
			// Clear count register
			TIM2->CNT = ((uint32_t)0x00000000);
			// Start timer
			TIM2->CR1 |= ((uint16_t)0x0001);
			// Update flag
			first_edgeSigGen = 1;
		}

		// Handle second edge
		else {
			// Stop timer
			TIM2->CR1 &= ((uint16_t)0xFFFE);
			// Read out count register
			count = (int)TIM2->CNT;
			// Calculate signal period by changing from CPU frequency (48MHz) to microseconds
			sig_period = period_calc(count);
			// Calculate signal frequency (+ 0.5 for rounding)
			sig_frequency = frequency_calc(count, sig_period);
			freq = (unsigned int) sig_frequency;
			// Reset flag
			first_edgeSigGen = 0;
		}

		// Clear EXTI2 interrupt pending flag
		EXTI->PR |= ((uint32_t)0x00000004); // A pending register (PR) bit is cleared by writing 1 to it

	}

}

void refresh_OLED(void) {

    // Buffer size = at most 16 characters per PAGE + null terminator
    unsigned char buffer[17];

    snprintf((char*)buffer, sizeof(buffer), "R: %5u Ohms", res); // Cast to char instead of using unsigned char
    /* Buffer now contains your character ASCII codes for LED Display
       - select PAGE (LED Display line) and set starting SEG (column)
       - for each c = ASCII code = Buffer[0], Buffer[1], ...,
           send 8 bytes in Characters[c][0-7] to LED Display (see "Interfacing" Slides 34-35)
     */

    // Select PAGE2
    oled_Write_Cmd(0xB2);
    // Select SEG3 (lower half)
    oled_Write_Cmd(0x03);
    // Select SEG3 (upper half)
    oled_Write_Cmd(0x10);

    // Read characters from buffer until reaching null terminator
    for (int i = 0; buffer[i] != '\0'; i++) {
    	// Retrieve 8 bytes and send them one at a time to LED display
    	for (int j = 0; j < 8; j++) {
    		oled_Write_Data(Characters[(int)buffer[i]][j]); // Cast buffer[i] to int to get ASCII code
    	}
    }

    snprintf((char*)buffer, sizeof(buffer), "F: %5u Hz", freq); // Cast to char instead of using unsigned char
    /* Buffer now contains your character ASCII codes for LED Display
       - select PAGE (LED Display line) and set starting SEG (column)
       - for each c = ASCII code = Buffer[0], Buffer[1], ...,
           send 8 bytes in Characters[c][0-7] to LED Display
    */

    // Same as above, but using PAGE4

    // Select PAGE4
    oled_Write_Cmd(0xB4);
    // Select SEG3 (lower half)
    oled_Write_Cmd(0x03);
    // Select SEG3 (upper half)
    oled_Write_Cmd(0x10);
    // Read characters from buffer until reaching null terminator
    for (int i = 0; buffer[i] != '\0'; i++) {
    	// Retrieve 8 bytes and send them one at a time to LED display
    	for (int j = 0; j < 8; j++) {
    		oled_Write_Data(Characters[(int)buffer[i]][j]); // Cast buffer[i] to int to get ASCII code
    	}
    }


	/* Wait for ~100 ms (for example) to get ~10 frames/sec refresh rate
       - You should use TIM3 to implement this delay (e.g., via polling)
    */
    delay(100);

}

void oled_Write_Cmd(unsigned char cmd) {

	// Set PB6 = CS# = 1
    GPIOB->BSRR |= GPIO_BSRR_BS_6;

    // Set PB7 = D/C# = 0
    GPIOB->BSRR |= GPIO_BSRR_BR_7;

    // Set PB6 = CS# = 0
    GPIOB->BSRR |= GPIO_BSRR_BR_6;

    oled_Write(cmd);

    // Set PB6 = CS# = 1
    GPIOB->BSRR |= GPIO_BSRR_BS_6;

}

void oled_Write_Data(unsigned char data) {

    // Set PB6 = CS# = 1
	GPIOB->BSRR |= GPIO_BSRR_BS_6;

    // Set PB7 = D/C# = 1
	GPIOB->BSRR |= GPIO_BSRR_BS_7;

    //Set PB6 = CS# = 0
	GPIOB->BSRR |= GPIO_BSRR_BR_6;

    oled_Write(data);

    // Set PB6 = CS# = 1
    GPIOB->BSRR |= GPIO_BSRR_BS_6;

}

void oled_Write(unsigned char Value) {

    // Wait until SPI1 is ready for writing
	while((SPI1->SR & 0x2) == 0); // Wait for TXE = 1 in SPI1_SR (see reference manual Page 759)

    // Send one 8-bit character (this function also sets BIDIOE = 1 in SPI1_CR1
    HAL_SPI_Transmit(&SPI_Handle, &Value, 1, HAL_MAX_DELAY);

    // Wait until transmission is complete (TXE = 1 in SPI1_SR) */
    while((SPI1->SR & 0x2) == 0); // Wait for TXE = 1 in SPI1_SR (see reference manual Page 759)

}

void oled_config(void) {

	// Don't forget to enable GPIOB clock in RCC - DONE (OK)
	// Don't forget to configure PB3/PB5 as AF0 - DONE (OK - GPIOBinit)
	// Don't forget to enable SPI1 clock in RCC - DONE (OK)

	// Enable SPI1 Clock
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;

	// Definitions
    SPI_Handle.Instance = SPI1;
    SPI_Handle.Init.Direction = SPI_DIRECTION_1LINE;
    SPI_Handle.Init.Mode = SPI_MODE_MASTER;
    SPI_Handle.Init.DataSize = SPI_DATASIZE_8BIT;
    SPI_Handle.Init.CLKPolarity = SPI_POLARITY_LOW;
    SPI_Handle.Init.CLKPhase = SPI_PHASE_1EDGE;
    SPI_Handle.Init.NSS = SPI_NSS_SOFT;
    SPI_Handle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
    SPI_Handle.Init.FirstBit = SPI_FIRSTBIT_MSB;
    SPI_Handle.Init.CRCPolynomial = 7;

    // Initialize the SPI interface
    HAL_SPI_Init( &SPI_Handle );

    // Enable the SPI
    __HAL_SPI_ENABLE( &SPI_Handle );


    // Reset LED display
	GPIOB->BSRR |= GPIO_BSRR_BR_4; 		// Make pin PB4 (RES#) = 0
	delay(3); 							// Wait for 3 ms
	GPIOB->BSRR |= GPIO_BSRR_BS_4; 		// Make pin PB4 (RES#) = 1
	delay(3);							// Wait for a few ms

	// Send initialization commands to LED display
    for ( unsigned int i = 0; i < sizeof( oled_init_cmds ); i++ ) {
        oled_Write_Cmd( oled_init_cmds[i] );
    }

    /* Fill LED Display data memory (GDDRAM) with zeros:
       - for each PAGE = 0, 1, ..., 7
           set starting SEG = 0
           call oled_Write_Data( 0x00 ) 128 times
    */

    // Go through all pages
    for (unsigned char i = 0xB0; i < 0xB8; i++) {

    	// Select PAGEi
    	oled_Write_Cmd(i);

    	// Set SEG0 (lower half)
    	oled_Write_Cmd(0x02);	// Always start lower at 02

    	// Set SEG0 (upper half)
    	oled_Write_Cmd(0x10);

    	// Write zeros to every SEG (128 times)
    	for (int j = 0; j < 128; j++) {
    		oled_Write_Data(0x00);
    	}

    }

}

void delay(uint32_t time){	// Milliseconds

	// Clear count register
	TIM3->CNT = ((uint32_t)0x00000000);

	// Start timer
	TIM3->CR1 |= TIM_CR1_CEN;

	// Wait for updated event
	while (TIM3->CNT < time);

	// Stop timer
	TIM3->CR1 &= ~TIM_CR1_CEN;

}

#pragma GCC diagnostic pop
